# 코루틴 딥다이브(마르친 모스카와)

---
1장 - 코틀린 코루틴을 배워야 하는 이유

스레드 사용의 비용:

스레드를 사용하는 데는 자원이 많이 소모된다.
스레드는 운영 체제 수준에서 관리되며, 스레드를 생성하고 관리하는 데 필요한 오버헤드가 존재한다.

자바에서 Thread.sleep의 비용:

Thread.sleep() 을 사용하면 해당 스레드는 정해진 시간 동안 실행을 멈추고 다른 스레드가 실행될 수 있게 한다.
이 과정에서도 스레드는 계속 자원을 점유하고 있으며, 컨텍스트 스위칭에도 비용이 발생한다.

코루틴의 중단과 재개:

코루틴은 스레드와 다르게 작동한다.
필요에 따라 실행을 중단(suspend)하고, 재개(resume)할 수 있다.
이 과정에서 코루틴은 스데르를 잠들게 하지 않고, 실행 중인 스레드를 활용하여 다른 작업으로 전환할 수 있다.
이러한 특성으로 인하여 컨텍스트 비용을 줄이고, 스레드 자원을 효율적으로 활용할 수 있다.

코루틴의 중단과 재개 좀 더 들어가보자

컨텍스트 스위칭의 최소화:

스레드를 사용할 때, 다른 스레드로 전환하기 위해서는 현재 스레드의 상태를 저장하고, 새 스레드의 상태를 불러오는 과정이 필요하다.
코루틴은 같은 스레드 내에서 여러 코루틴 간에 전환할 때 이러한 컨텍스트 스위칭이 필요 없다.
코루틴은 현재 스레드의 실행 흐름을 가볍게 중단하고 다른 코루틴으로 전환할 수 있으며, 이는 스레드 전환보다 훨씬 빠르고 가볍다.

코루틴 과 스레드

코루틴은 스레드와 다른 접근 방식을 취합니다.
코루틴의 중단은 스레드의 중단과 다르다. 코루틴이 중단될 때, 그 코루틴을 실행하던 스레드는 다른 코루틴이나 작업을 수행할 수 있다.
즉 코루틴은 스레드를 차지하지 않고 중단될 수 있으며, 이로 인해 한 스레드에서 여러 코루틴이 효율적으로 동작할 수 있다.

코루틴 과 자원

이러한 특성으로 자원을 보다 효율적으로 사용하게 한다.
코루틴의 작업이 중단 되었을 때, 해당 스레드는 다른 작업을 재할당될 수 있으며, 이는 전통적인 스레드 방식보다 훨씬 더 많은 작업을 더 적은 수의 스레드로 처리할 수 있게 해준다.

그럼 코루틴이 중단 됐을때 작업할 내용이 없다면?

일시적으로 작업을 수행하지 않는다.
스레드가 유휴 상태(idle)에 있게 되며, 시스템 리소스를 절약하는 효과를 가진다.
유휴 상태일 경우 cpu 시간을 소비하지 않는다.
중단된 코루틴의 작업이 완료되고 실행을 재개할 준비가 된다면, 코루틴은 다시 활성화를 가지고 실행된다
이때 코루틴은 중단 전의 상태를 그대로 유지하며, 중단 지점부터 실행을 수행한다.

---
2장 - 시퀀스 빌더

코틀린 시퀀스는 데이터를 연속적으로 처리하는 데 사용되는 컬렉션 타입 중 하나

요구되는 연산을 최소한으로 수행
무한정이 될 수 있음
메모리 사용이 효율

시퀀스 좀 알고 갈까

리스트를 사용할 경우

val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)val result = mutableListOf<Int>()for(number in numbers){ if(number %
2 == 0){ val squared = number*number result.add(squared)}}println(result)//[4, 16, 36, 64, 100]

위 코드는 리스트를 사용하여 짝수를 찾고 제곱한 값을 구합니다. 중간 결과를 담을 result 리스트를 생성하고, 반복문을 통해 필터링 및 제곱을 수행합니다.

시퀀스를 사용한 경우

val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)val result = numbers.asSequence().filter { it % 2 == 0 } // 짝수 필터링
.map { it*it } // 제곱 연산 .toList()// 최종 결과를 리스트로 변환println(result)//[4, 16, 36, 64, 100]

위 코드는 시퀀스를 사용하여 짝수를 찾고 제곱한 값을 구합니다. asSequence()를 사용하여 리스트를 시퀀스로 변환하고, filter로 짝수를 필터링하며, map으로 제곱 연산을 합니다. 중간 결과를 생성하지
않고 필요한 시점에서만 연산이 수행되므로, 메모리와 연산을 더 효율적으로 사용합니다.

그래서 뭐가 좋은데?

지연 평가 (Lazy Evaluation):

시퀀스는 연산을 지연시킵니다.
중간 연산인 filter, map 등이 호출되더라도 실제 연산이 수행되지 않고 대기함.
모든 연산을 끝까지 실행하지 않고, 필요한 시점에서만 실행한다는 의미.

연산을 중간에 중단하거나 조건에 따라 실행 여부를 결정할 수 있다.
모든 데이터를 한 번에 메모리에 로드하지 않고, 데이터를 순차적으로 읽어들이므로 메모리 효율성 향상.

중간 결과 생성 최소화:

중간 결과를 생성하지 않고 연산을 수행합니다.
예를들어 리스트를 사용할 때 중간 결과를 저장하기 위해 새로운 리스트를 만들어야 함.
시퀀스는 중간 결과를 생성하지 않고 필터링 및 매핑 연산을 미뤄두어, 중간 결과를 생성하는 비용이 없어지므로 연산이 더 효율적으로 수행

이러한 장점은 대용량 데이터를 처리할 때 더욱 좋음
주의할점?

정말 많은 데이터 ex)몇억개의 데이터를 처리할때는 메모리 상황과 효율성을 중요시 해야할듯.

청크 기반으로 데이터를 n 개 씩 나눠서 처리를 하던지.
코루틴을 사용하여 병렬로 처리를 하던지
