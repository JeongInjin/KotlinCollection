# 코루틴 딥다이브(마르친 모스카와)

---

# 1장 - 코틀린 코루틴을 배워야 하는 이유

스레드 사용의 비용:

스레드를 사용하는 데는 자원이 많이 소모된다.
스레드는 운영 체제 수준에서 관리되며, 스레드를 생성하고 관리하는 데 필요한 오버헤드가 존재한다.

자바에서 Thread.sleep의 비용:

Thread.sleep() 을 사용하면 해당 스레드는 정해진 시간 동안 실행을 멈추고 다른 스레드가 실행될 수 있게 한다.
이 과정에서도 스레드는 계속 자원을 점유하고 있으며, 컨텍스트 스위칭에도 비용이 발생한다.

코루틴의 중단과 재개:

코루틴은 스레드와 다르게 작동한다.
필요에 따라 실행을 중단(suspend)하고, 재개(resume)할 수 있다.
이 과정에서 코루틴은 스데르를 잠들게 하지 않고, 실행 중인 스레드를 활용하여 다른 작업으로 전환할 수 있다.
이러한 특성으로 인하여 컨텍스트 비용을 줄이고, 스레드 자원을 효율적으로 활용할 수 있다.

코루틴의 중단과 재개 좀 더 들어가보자

컨텍스트 스위칭의 최소화:

스레드를 사용할 때, 다른 스레드로 전환하기 위해서는 현재 스레드의 상태를 저장하고, 새 스레드의 상태를 불러오는 과정이 필요하다.
코루틴은 같은 스레드 내에서 여러 코루틴 간에 전환할 때 이러한 컨텍스트 스위칭이 필요 없다.
코루틴은 현재 스레드의 실행 흐름을 가볍게 중단하고 다른 코루틴으로 전환할 수 있으며, 이는 스레드 전환보다 훨씬 빠르고 가볍다.

코루틴 과 스레드

코루틴은 스레드와 다른 접근 방식을 취합니다.
코루틴의 중단은 스레드의 중단과 다르다. 코루틴이 중단될 때, 그 코루틴을 실행하던 스레드는 다른 코루틴이나 작업을 수행할 수 있다.
즉 코루틴은 스레드를 차지하지 않고 중단될 수 있으며, 이로 인해 한 스레드에서 여러 코루틴이 효율적으로 동작할 수 있다.

코루틴 과 자원

이러한 특성으로 자원을 보다 효율적으로 사용하게 한다.
코루틴의 작업이 중단 되었을 때, 해당 스레드는 다른 작업을 재할당될 수 있으며, 이는 전통적인 스레드 방식보다 훨씬 더 많은 작업을 더 적은 수의 스레드로 처리할 수 있게 해준다.

그럼 코루틴이 중단 됐을때 작업할 내용이 없다면?

일시적으로 작업을 수행하지 않는다.
스레드가 유휴 상태(idle)에 있게 되며, 시스템 리소스를 절약하는 효과를 가진다.
유휴 상태일 경우 cpu 시간을 소비하지 않는다.
중단된 코루틴의 작업이 완료되고 실행을 재개할 준비가 된다면, 코루틴은 다시 활성화를 가지고 실행된다
이때 코루틴은 중단 전의 상태를 그대로 유지하며, 중단 지점부터 실행을 수행한다.

---

# 2장 - 시퀀스 빌더

코틀린 시퀀스는 데이터를 연속적으로 처리하는 데 사용되는 컬렉션 타입 중 하나

요구되는 연산을 최소한으로 수행
무한정이 될 수 있음
메모리 사용이 효율

시퀀스 좀 알고 갈까

리스트를 사용할 경우

val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)val result = mutableListOf<Int>()for(number in numbers){ if(number %
2 == 0){ val squared = number*number result.add(squared)}}println(result)//[4, 16, 36, 64, 100]

위 코드는 리스트를 사용하여 짝수를 찾고 제곱한 값을 구합니다. 중간 결과를 담을 result 리스트를 생성하고, 반복문을 통해 필터링 및 제곱을 수행합니다.

시퀀스를 사용한 경우

val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)val result = numbers.asSequence().filter { it % 2 == 0 } // 짝수 필터링
.map { it*it } // 제곱 연산 .toList()// 최종 결과를 리스트로 변환println(result)//[4, 16, 36, 64, 100]

위 코드는 시퀀스를 사용하여 짝수를 찾고 제곱한 값을 구합니다. asSequence()를 사용하여 리스트를 시퀀스로 변환하고, filter로 짝수를 필터링하며, map으로 제곱 연산을 합니다. 중간 결과를 생성하지
않고 필요한 시점에서만 연산이 수행되므로, 메모리와 연산을 더 효율적으로 사용합니다.

그래서 뭐가 좋은데?

지연 평가 (Lazy Evaluation):

시퀀스는 연산을 지연시킵니다.
중간 연산인 filter, map 등이 호출되더라도 실제 연산이 수행되지 않고 대기함.
모든 연산을 끝까지 실행하지 않고, 필요한 시점에서만 실행한다는 의미.

연산을 중간에 중단하거나 조건에 따라 실행 여부를 결정할 수 있다.
모든 데이터를 한 번에 메모리에 로드하지 않고, 데이터를 순차적으로 읽어들이므로 메모리 효율성 향상.

중간 결과 생성 최소화:

중간 결과를 생성하지 않고 연산을 수행합니다.
예를들어 리스트를 사용할 때 중간 결과를 저장하기 위해 새로운 리스트를 만들어야 함.
시퀀스는 중간 결과를 생성하지 않고 필터링 및 매핑 연산을 미뤄두어, 중간 결과를 생성하는 비용이 없어지므로 연산이 더 효율적으로 수행

이러한 장점은 대용량 데이터를 처리할 때 더욱 좋음
주의할점?

정말 많은 데이터 ex)몇억개의 데이터를 처리할때는 메모리 상황과 효율성을 중요시 해야할듯.

청크 기반으로 데이터를 n 개 씩 나눠서 처리를 하던지.
코루틴을 사용하여 병렬로 처리를 하던지
---

# 3장 - 중단은 어떻게 작동할까?

중단 함수는 코틀린 코루틴의 핵심이다.
코루틴은 중단되었을 때 Continuation 객체를 반환한다.
중단했을 때 어떤 자원도 사용하지 않는다

실행이 중지 되어있을 때 스레드를 차지하지 않아 다른 작업에 스레드를 할당할 수 있다는 뜻.

delay - 중단

코루틴의 실행을 지정된 시간 동안 일시적으로 중단하는 데 사용된다.
delay(timeInMillis) 함수는 매개변수(ms) 단위로 현재 코루틴을 중단하며 시간이 지나면 자동으로 다시 시작된다.
비블로킹 특성을 가진다.

스레드를 차단하지 않는다.
코루틴은 일시 중단되지만, 그 로쿠틴이 실행되고 있던 스레드는 다른 작업을 계속 수행할 수 있다.

지정된 시간이 지난 후에는 중단되었던 지점에서 실행을 재개하는데, 이과정은 코루틴의 컨티뉴에이션 매커니즘을 통해 이루어 진다.
코루틴 블록 또는 suspend 함수 내부에서만 호출할 수 있다.

resume - 재개

resume 함수에 Unit 을 인자로 넣는다.suspendConroutine 의 타입 인자로 Unit 을 사용한다

Unit

자바의 void 와 유사한 역할을 하지만 Unit 은 객체로서의 특성을 가진 실제 타입
Unit 은 객체이므로, 변수에 할당하거나 다른 함수의 매개변수로 전달할 수 있다.
Unit 을 반환하는 타입은 명시적으로 Unit 이라 지정하지 않아도 Unit을 반환한다.

실패에 대한 처리

만약 외부 api 호출시 실패에 의한 에러 처리를 원한다면?

resumeWithException 사용

비동기 작업이 실패했을 때 예외를 코루틴으로 전파합니다. 이 방법은 코루틴의 중단 지점에서 실패를 처리하고자 할 때 유용합니다.

try catch 형식으로 처리할 수 있다.

suspend fun fetchApiData():ApiResponse { return try { // API 호출 apiService.getData()} catch(e:Exception){ // 예외 처리
handleError(e)}}

타임아웃 처리

suspend fun fetchApiDataWithTimeout():ApiResponse? { return withTimeoutOrNull(5000L){ // 5초 타임아웃 apiService.getData()}}

재시도 로직

suspend fun fetchApiDataWithRetry(retries:Int = 3):ApiResponse? { repeat(retries){ try { return apiService.getData()}
catch(e:Exception){ if(it == retries - 1)throw e } } return null}

코루틴 핸들러 사용- CoroutineExceptionHandler ㄹㄹ 사용하여 코루틴 스코프 내에서 발생하는 모든 예외를 처리할 수 있다. 이 방법은 코루틴 스코프 전체에 대한 에러 처리가 필요할 때 유용하다.

val handler = CoroutineExceptionHandler {_, exception ->handleError(exception)}val scope = CoroutineScope(Job()+
Dispatchers.Main + handler)scope.launch { // API 호출}

응답 검증 - api 의 응답을 검증하여 처리한다.

suspend fun fetchApiData():ApiResponse { val response = apiService.getData()if(response.isSuccessful){ return
response.body()?:throw ApiException("No data")} else { throw ApiException("API Error:${response.code()}")}}

---

# 4장 - 코루틴의 실제 구현

중단 함수는 함수가 시작할 때와 중단 함수가 호출되었을 때 상태를 가진다는 점에서 상태 머신과 비슷합니다.

상태머신: 코루틴의 실행 과정은 내부적으로 상태 머신으로 변환됩니다.코루틴은 여러 상태(예: 시작, 중단, 재개, 완료)를 가질 수 있으며, 이러한 상태는 코루틴의 생명주기를 관리 한다.

컨티뉴에이션 객체는 상태를 나타내는 숫자와 로컬 데이터를 가지고 있다.
함수의 컨티뉴에이션 객체가 이 함수를 부르는 다른 함수의 컨티뉴에이션 객체를 장식합니다. 그 결과, 모든 컨티뉴에이션 객체는 실행을 재개하거나 재개된 함수를 완료할 때 사용되는 콜 스택으로 사용됩니다.

 

컨디뉴에이션 전달 방식

중단 함수가 구현될 수 있는 수많은 방법 중에서 코틀린 팀은 컨티뉴에이션 전달 방식을 택함.
컨티뉴에이션은 코루틴이 중단된 지점의 정보를 담고 있다.

현재의 로컬 변수 값, 중단된 위치, 코루틴이 다시 시작될 때 필요한 다른 정보들이 포함됨

1.중단 함수 호출:

코루틴 내에서 suspend 키워드가 붙은 중단 함수를 호출하면 코루틴은 해당 지점에서 실행을 중단하고, 중단 함수는 컨티뉴에이션을 매개변수로 받는다

2.컨티뉴에이션 객체 생성 및 저장

코루틴이 중단될 때, 현재의 실행 상태는 컨티뉴에이션 객체에 저장된다. 이 객체는 코루틴의 상태 및 중단된 위치의 정보를 포함하고 있다.

3.컨티뉴에이션을 통한 재개

비동기 작업이 완료되면, 컨티뉴에이션을 통해 코루틴을 다시 시작할 수 있다.
resume 또는 resumeWithException 메서드를 사용하여 코루틴을 재개한다.

lable

코루틴에서 중단과 재개 시 사용되는 lable 은 코루틴이 중단된 지점을 식별하는 데 사용되는 내부 메커니즘.

기타

컨티뉴에이션은 한번만 재개될 수 있다 한번 resume 또는 resumeWithException 을 호출하면 같은 컨티뉴에이션을 다시 사용할 수 없다

콜 스택

전통적인 스레드에서는 각 스레드가 자신의 콜 스택을 가지고 있다.이 콜 스택에서는 함슈 호출의 기록, 로컬 변수, 반환 주소 등이 저장된다.
코루틴은 전통적인 스레드와는 다르다.

코루틴에서는 콜 스택이 가상화 된다.
즉 코루틴이 중단되었다가 재개될 때, 기존의 콜 스택 상태를 복원하고 관리하는 방식의 스레드의 콜 스택과는 다르다.
코루틴은 중단 가능한 지점에서 실행 상태(콜 스택의 정보)를 저장하고, 나중에 이상태를 다시 불러와서 코루틴을 재개한다.

코루틴의 콜 스택 관리

상태저장

코루틴은 suspend 함수를 만나 중단될 때, 현재의 콜 스택상태(함수 호출 정보, 로컬 변수 등)는 컨티뉴에이션 객체 내에 저장된다.

상태 복원 및 재개

코루틴이 재개될 때, 이전의 저장된 콜 스택 상태가 복원된다.이를 통해 코루틴은 중단되었던 지점부터 실행을 계속할 수 있다.

코루틴의 콜 스택과 성능

코루틴은 이러한 콜 스택 관리 방식은 여러 면에서 성능 이점을 제공

가벼움: 전통적인 스레드 보다 가벼우며, 많은 수의 코루틴을 동시에 실행할 수 있다.이는 코루틴의 콜 스택이 더 적은 메모리를 사용하기 때문
유연성: 코루틴은 콜 스택의 상태를 자유롭게 저장하고 복원할 수 있어, 비동기 작업을 더 유연하게 처리할 수 있다.
비동기 최적화: 코루틴은 비동기 작업에서 스레드를 차단하지 않는다. 이는 콜 스택의 상태를 저장하고 복원하는 능력 덕분에 가능하다.

전통적인 스레드?코루틴은 다르다?

전통적인 스레드의 콜 스택

고정된 스택 크기:고정된 스택의 크기를 가지고 있으며, 이 스택에는 함수 호출 기록, 로컬 변수, 반환 주소 등이 저장됨
운영체제 관리: 스레드의 콜 스택은 운영체제에 의해 관리된다.스레드가 실행될 때, 운영체제는 이 스레드에 대한 콜 스택을 할당하고 관리함.
블로킹 작업: 스레드가 대기상태(ex:I/O 작업대기)에 들어가면, 해당 스레드의 콜 스택은 그 상태로 유지된다. 이는 스레드가 자원을 계속 점유하고 있음을 의미

코루틴의 콜 스택

가상의 콜 스택: 코루틴은 가상의 콜 스택을 사용한다.이는 코루틴이 중단되었을 때 현재의 실행상태를 외부에 저장하고, 재개될 때 다시 불러올 수 있음을 의미한다.
컨티뉴에이션을 통한 관리: 코루틴의 콜 스택 상태는 컨티뉴에이션 객체에 저장된다.코루틴이 중단되면, 현재의 콜 스택상태(함수 호출, 로컬변수 등)는 컨티뉴에이션에 저장되고, 코루틴이 재개될때 이 상태가 다시 복원됨
비동기 작업 최적화: 비동기 작업을 기다리는 동안 스레드를 차단하지 않는다.대신 콜스택 상태를 저장하고 스레드를 다른 작업에 활용할 수 있다.

그래서 핵심은?

메모리사용: 코루틴은 전통적인 스레드보다 훨씬 적은 메모리를 사용한다.코루틴이 실행 상태를 필요에 따라 저장하고 복원하기 때문이다
비동기 처리: 코루틴은 비동기 처리에 최적화되어 있다.중단과 재개가 가능하므로, I/O 작업과 같은 블로킹 작업에 스레드를 낭비하지 않는다.
효율적인 자원 관리: 코루틴은 자원을 보다 효율적으로 관리할 수 있다.하나의 스레드에서 여러 코루틴을 실행할 수 있으며 이는 컨텍스트 스위칭 비용을 줄여준다.

기타

코루틴이 중단될 때, 현재의 실행상태는 컨티뉴에이션 객체에 저장되는데 컨티뉴에이션은 힙 메모리에 저장되며, 재개될 때 이 객체를 통해 실행 상태가 복원된다. 이는 코루틴이 실제 물리적인 스택 메모리를 연속적으로
사용하지 않음을 의미한다.
코루틴은 실행 중일 때 물리적인 스택을 사용하고, 중단과 재개를 수행할 때는 컨티뉴에이션(즉, 힙 메모리)을 사용한다
왜 가상의 스택 이라는 용어를..?

전통적인 스택과의 차별화: 일반적인 스레드는 물리적 스택 메모리를 연속적으로 사용하지만, 코루틴은 중단과 재개가 가능하며 이 과정에서 실행 상태는 힙 메모리에 위치하는 컨티뉴에이션 객체에 저장.이러한 차이점을
강조하기 위헤 가상의 라는 용어를 사용

---

# 6장 - 코루틴 빌더

launch 빌더

launch 빌더는 새로운 코루틴을 시작하고, 결과를 반환하지 않습니다(Unit을 반환).
주로 병렬 작업을 수행할 때 사용하며, 작업이 완료될 때까지 기다리지 않습니다.
launch로 시작된 코루틴은 부모 코루틴의 생명주기에 연결되어 부모가 취소되면 자식도 취소됩니다.

runBlocking 빌더

runBlocking은 현재 스레드를 블록하고 코루틴이 완료될 때까지 기다립니다.
주로 테스트나 메인 함수에서 코루틴 코드를 실행하기 위해 사용됩니다.
runBlocking 내부에서는 다른 코루틴을 시작할 수 있으며, 내부 코루틴이 모두 완료될 때까지 기다립니다.

async 빌더

async 빌더는 코루틴을 시작하고 Deferred 타입의 결과를 반환합니다.
반환된 Deferred 객체를 통해 나중에 결과값을 받을 수 있으며, await 함수를 호출하여 결과값을 기다릴 수 있습니다.
주로 결과 값을 반환하는 병렬 작업에 사용됩니다.

coroutineScope

코루틴 스코프의 인스턴스를 생성하여 코루틴을 관리할 수 있습니다.
CoroutineScope를 사용하면 코루틴의 생명주기를 해당 스코프의 생명주기에 연결할 수 있습니다. 즉, 스코프가 취소되면 스코프 내의 모든 코루틴도 취소됩니다.
사용자가 직접 스코프를 관리하고 싶을 때 사용합니다.

GlobalScope
애플리케이션의 생명주기와 동일한 글로벌 스코프를 제공합니다.
GlobalScope로 시작된 코루틴은 애플리케이션 전체에서 실행되며, 별도로 취소하지 않는 이상 애플리케이션이 종료될 때까지 계속 실행됩니다.
메모리 누수의 위험이 있으므로, 주의해서 사용해야 합니다.

코루틴 스코프의 선택은 코루틴의 생명주기와 애플리케이션의 구조에 따라 달라집니다. 일반적으로 GlobalScope의 사용은 권장되지 않으며, 가능하면 CoroutineScope를 사용하여 명확한 생명주기 관리와 자원
정리를 수행하는 것이 좋습니다.

---
