# 코루틴 딥다이브(마르친 모스카와)

---

# 1장 - 코틀린 코루틴을 배워야 하는 이유

스레드 사용의 비용:

스레드를 사용하는 데는 자원이 많이 소모된다.
스레드는 운영 체제 수준에서 관리되며, 스레드를 생성하고 관리하는 데 필요한 오버헤드가 존재한다.

자바에서 Thread.sleep의 비용:

Thread.sleep() 을 사용하면 해당 스레드는 정해진 시간 동안 실행을 멈추고 다른 스레드가 실행될 수 있게 한다.
이 과정에서도 스레드는 계속 자원을 점유하고 있으며, 컨텍스트 스위칭에도 비용이 발생한다.

코루틴의 중단과 재개:

코루틴은 스레드와 다르게 작동한다.
필요에 따라 실행을 중단(suspend)하고, 재개(resume)할 수 있다.
이 과정에서 코루틴은 스데르를 잠들게 하지 않고, 실행 중인 스레드를 활용하여 다른 작업으로 전환할 수 있다.
이러한 특성으로 인하여 컨텍스트 비용을 줄이고, 스레드 자원을 효율적으로 활용할 수 있다.

코루틴의 중단과 재개 좀 더 들어가보자

컨텍스트 스위칭의 최소화:

스레드를 사용할 때, 다른 스레드로 전환하기 위해서는 현재 스레드의 상태를 저장하고, 새 스레드의 상태를 불러오는 과정이 필요하다.
코루틴은 같은 스레드 내에서 여러 코루틴 간에 전환할 때 이러한 컨텍스트 스위칭이 필요 없다.
코루틴은 현재 스레드의 실행 흐름을 가볍게 중단하고 다른 코루틴으로 전환할 수 있으며, 이는 스레드 전환보다 훨씬 빠르고 가볍다.

코루틴 과 스레드

코루틴은 스레드와 다른 접근 방식을 취합니다.
코루틴의 중단은 스레드의 중단과 다르다. 코루틴이 중단될 때, 그 코루틴을 실행하던 스레드는 다른 코루틴이나 작업을 수행할 수 있다.
즉 코루틴은 스레드를 차지하지 않고 중단될 수 있으며, 이로 인해 한 스레드에서 여러 코루틴이 효율적으로 동작할 수 있다.

코루틴 과 자원

이러한 특성으로 자원을 보다 효율적으로 사용하게 한다.
코루틴의 작업이 중단 되었을 때, 해당 스레드는 다른 작업을 재할당될 수 있으며, 이는 전통적인 스레드 방식보다 훨씬 더 많은 작업을 더 적은 수의 스레드로 처리할 수 있게 해준다.

그럼 코루틴이 중단 됐을때 작업할 내용이 없다면?

일시적으로 작업을 수행하지 않는다.
스레드가 유휴 상태(idle)에 있게 되며, 시스템 리소스를 절약하는 효과를 가진다.
유휴 상태일 경우 cpu 시간을 소비하지 않는다.
중단된 코루틴의 작업이 완료되고 실행을 재개할 준비가 된다면, 코루틴은 다시 활성화를 가지고 실행된다
이때 코루틴은 중단 전의 상태를 그대로 유지하며, 중단 지점부터 실행을 수행한다.

---

# 2장 - 시퀀스 빌더

코틀린 시퀀스는 데이터를 연속적으로 처리하는 데 사용되는 컬렉션 타입 중 하나

요구되는 연산을 최소한으로 수행
무한정이 될 수 있음
메모리 사용이 효율

시퀀스 좀 알고 갈까

리스트를 사용할 경우

val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)val result = mutableListOf<Int>()for(number in numbers){ if(number %
2 == 0){ val squared = number*number result.add(squared)}}println(result)//[4, 16, 36, 64, 100]

위 코드는 리스트를 사용하여 짝수를 찾고 제곱한 값을 구합니다. 중간 결과를 담을 result 리스트를 생성하고, 반복문을 통해 필터링 및 제곱을 수행합니다.

시퀀스를 사용한 경우

val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)val result = numbers.asSequence().filter { it % 2 == 0 } // 짝수 필터링
.map { it*it } // 제곱 연산 .toList()// 최종 결과를 리스트로 변환println(result)//[4, 16, 36, 64, 100]

위 코드는 시퀀스를 사용하여 짝수를 찾고 제곱한 값을 구합니다. asSequence()를 사용하여 리스트를 시퀀스로 변환하고, filter로 짝수를 필터링하며, map으로 제곱 연산을 합니다. 중간 결과를 생성하지
않고 필요한 시점에서만 연산이 수행되므로, 메모리와 연산을 더 효율적으로 사용합니다.

그래서 뭐가 좋은데?

지연 평가 (Lazy Evaluation):

시퀀스는 연산을 지연시킵니다.
중간 연산인 filter, map 등이 호출되더라도 실제 연산이 수행되지 않고 대기함.
모든 연산을 끝까지 실행하지 않고, 필요한 시점에서만 실행한다는 의미.

연산을 중간에 중단하거나 조건에 따라 실행 여부를 결정할 수 있다.
모든 데이터를 한 번에 메모리에 로드하지 않고, 데이터를 순차적으로 읽어들이므로 메모리 효율성 향상.

중간 결과 생성 최소화:

중간 결과를 생성하지 않고 연산을 수행합니다.
예를들어 리스트를 사용할 때 중간 결과를 저장하기 위해 새로운 리스트를 만들어야 함.
시퀀스는 중간 결과를 생성하지 않고 필터링 및 매핑 연산을 미뤄두어, 중간 결과를 생성하는 비용이 없어지므로 연산이 더 효율적으로 수행

이러한 장점은 대용량 데이터를 처리할 때 더욱 좋음
주의할점?

정말 많은 데이터 ex)몇억개의 데이터를 처리할때는 메모리 상황과 효율성을 중요시 해야할듯.

청크 기반으로 데이터를 n 개 씩 나눠서 처리를 하던지.
코루틴을 사용하여 병렬로 처리를 하던지
---

# 3장 - 중단은 어떻게 작동할까?

중단 함수는 코틀린 코루틴의 핵심이다.
코루틴은 중단되었을 때 Continuation 객체를 반환한다.
중단했을 때 어떤 자원도 사용하지 않는다

실행이 중지 되어있을 때 스레드를 차지하지 않아 다른 작업에 스레드를 할당할 수 있다는 뜻.

delay - 중단

코루틴의 실행을 지정된 시간 동안 일시적으로 중단하는 데 사용된다.
delay(timeInMillis) 함수는 매개변수(ms) 단위로 현재 코루틴을 중단하며 시간이 지나면 자동으로 다시 시작된다.
비블로킹 특성을 가진다.

스레드를 차단하지 않는다.
코루틴은 일시 중단되지만, 그 로쿠틴이 실행되고 있던 스레드는 다른 작업을 계속 수행할 수 있다.

지정된 시간이 지난 후에는 중단되었던 지점에서 실행을 재개하는데, 이과정은 코루틴의 컨티뉴에이션 매커니즘을 통해 이루어 진다.
코루틴 블록 또는 suspend 함수 내부에서만 호출할 수 있다.

resume - 재개

resume 함수에 Unit 을 인자로 넣는다.suspendConroutine 의 타입 인자로 Unit 을 사용한다

Unit

자바의 void 와 유사한 역할을 하지만 Unit 은 객체로서의 특성을 가진 실제 타입
Unit 은 객체이므로, 변수에 할당하거나 다른 함수의 매개변수로 전달할 수 있다.
Unit 을 반환하는 타입은 명시적으로 Unit 이라 지정하지 않아도 Unit을 반환한다.

실패에 대한 처리

만약 외부 api 호출시 실패에 의한 에러 처리를 원한다면?

resumeWithException 사용

비동기 작업이 실패했을 때 예외를 코루틴으로 전파합니다. 이 방법은 코루틴의 중단 지점에서 실패를 처리하고자 할 때 유용합니다.

try catch 형식으로 처리할 수 있다.

suspend fun fetchApiData():ApiResponse { return try { // API 호출 apiService.getData()} catch(e:Exception){ // 예외 처리
handleError(e)}}

타임아웃 처리

suspend fun fetchApiDataWithTimeout():ApiResponse? { return withTimeoutOrNull(5000L){ // 5초 타임아웃 apiService.getData()}}

재시도 로직

suspend fun fetchApiDataWithRetry(retries:Int = 3):ApiResponse? { repeat(retries){ try { return apiService.getData()}
catch(e:Exception){ if(it == retries - 1)throw e } } return null}

코루틴 핸들러 사용- CoroutineExceptionHandler ㄹㄹ 사용하여 코루틴 스코프 내에서 발생하는 모든 예외를 처리할 수 있다. 이 방법은 코루틴 스코프 전체에 대한 에러 처리가 필요할 때 유용하다.

val handler = CoroutineExceptionHandler {_, exception ->handleError(exception)}val scope = CoroutineScope(Job()+
Dispatchers.Main + handler)scope.launch { // API 호출}

응답 검증 - api 의 응답을 검증하여 처리한다.

suspend fun fetchApiData():ApiResponse { val response = apiService.getData()if(response.isSuccessful){ return
response.body()?:throw ApiException("No data")} else { throw ApiException("API Error:${response.code()}")}}

---

# 4장 - 코루틴의 실제 구현

중단 함수는 함수가 시작할 때와 중단 함수가 호출되었을 때 상태를 가진다는 점에서 상태 머신과 비슷합니다.

상태머신: 코루틴의 실행 과정은 내부적으로 상태 머신으로 변환됩니다.코루틴은 여러 상태(예: 시작, 중단, 재개, 완료)를 가질 수 있으며, 이러한 상태는 코루틴의 생명주기를 관리 한다.

컨티뉴에이션 객체는 상태를 나타내는 숫자와 로컬 데이터를 가지고 있다.
함수의 컨티뉴에이션 객체가 이 함수를 부르는 다른 함수의 컨티뉴에이션 객체를 장식합니다. 그 결과, 모든 컨티뉴에이션 객체는 실행을 재개하거나 재개된 함수를 완료할 때 사용되는 콜 스택으로 사용됩니다.

 

컨디뉴에이션 전달 방식

중단 함수가 구현될 수 있는 수많은 방법 중에서 코틀린 팀은 컨티뉴에이션 전달 방식을 택함.
컨티뉴에이션은 코루틴이 중단된 지점의 정보를 담고 있다.

현재의 로컬 변수 값, 중단된 위치, 코루틴이 다시 시작될 때 필요한 다른 정보들이 포함됨

1.중단 함수 호출:

코루틴 내에서 suspend 키워드가 붙은 중단 함수를 호출하면 코루틴은 해당 지점에서 실행을 중단하고, 중단 함수는 컨티뉴에이션을 매개변수로 받는다

2.컨티뉴에이션 객체 생성 및 저장

코루틴이 중단될 때, 현재의 실행 상태는 컨티뉴에이션 객체에 저장된다. 이 객체는 코루틴의 상태 및 중단된 위치의 정보를 포함하고 있다.

3.컨티뉴에이션을 통한 재개

비동기 작업이 완료되면, 컨티뉴에이션을 통해 코루틴을 다시 시작할 수 있다.
resume 또는 resumeWithException 메서드를 사용하여 코루틴을 재개한다.

lable

코루틴에서 중단과 재개 시 사용되는 lable 은 코루틴이 중단된 지점을 식별하는 데 사용되는 내부 메커니즘.

기타

컨티뉴에이션은 한번만 재개될 수 있다 한번 resume 또는 resumeWithException 을 호출하면 같은 컨티뉴에이션을 다시 사용할 수 없다

콜 스택

전통적인 스레드에서는 각 스레드가 자신의 콜 스택을 가지고 있다.이 콜 스택에서는 함슈 호출의 기록, 로컬 변수, 반환 주소 등이 저장된다.
코루틴은 전통적인 스레드와는 다르다.

코루틴에서는 콜 스택이 가상화 된다.
즉 코루틴이 중단되었다가 재개될 때, 기존의 콜 스택 상태를 복원하고 관리하는 방식의 스레드의 콜 스택과는 다르다.
코루틴은 중단 가능한 지점에서 실행 상태(콜 스택의 정보)를 저장하고, 나중에 이상태를 다시 불러와서 코루틴을 재개한다.

코루틴의 콜 스택 관리

상태저장

코루틴은 suspend 함수를 만나 중단될 때, 현재의 콜 스택상태(함수 호출 정보, 로컬 변수 등)는 컨티뉴에이션 객체 내에 저장된다.

상태 복원 및 재개

코루틴이 재개될 때, 이전의 저장된 콜 스택 상태가 복원된다.이를 통해 코루틴은 중단되었던 지점부터 실행을 계속할 수 있다.

코루틴의 콜 스택과 성능

코루틴은 이러한 콜 스택 관리 방식은 여러 면에서 성능 이점을 제공

가벼움: 전통적인 스레드 보다 가벼우며, 많은 수의 코루틴을 동시에 실행할 수 있다.이는 코루틴의 콜 스택이 더 적은 메모리를 사용하기 때문
유연성: 코루틴은 콜 스택의 상태를 자유롭게 저장하고 복원할 수 있어, 비동기 작업을 더 유연하게 처리할 수 있다.
비동기 최적화: 코루틴은 비동기 작업에서 스레드를 차단하지 않는다. 이는 콜 스택의 상태를 저장하고 복원하는 능력 덕분에 가능하다.

전통적인 스레드?코루틴은 다르다?

전통적인 스레드의 콜 스택

고정된 스택 크기:고정된 스택의 크기를 가지고 있으며, 이 스택에는 함수 호출 기록, 로컬 변수, 반환 주소 등이 저장됨
운영체제 관리: 스레드의 콜 스택은 운영체제에 의해 관리된다.스레드가 실행될 때, 운영체제는 이 스레드에 대한 콜 스택을 할당하고 관리함.
블로킹 작업: 스레드가 대기상태(ex:I/O 작업대기)에 들어가면, 해당 스레드의 콜 스택은 그 상태로 유지된다. 이는 스레드가 자원을 계속 점유하고 있음을 의미

코루틴의 콜 스택

가상의 콜 스택: 코루틴은 가상의 콜 스택을 사용한다.이는 코루틴이 중단되었을 때 현재의 실행상태를 외부에 저장하고, 재개될 때 다시 불러올 수 있음을 의미한다.
컨티뉴에이션을 통한 관리: 코루틴의 콜 스택 상태는 컨티뉴에이션 객체에 저장된다.코루틴이 중단되면, 현재의 콜 스택상태(함수 호출, 로컬변수 등)는 컨티뉴에이션에 저장되고, 코루틴이 재개될때 이 상태가 다시 복원됨
비동기 작업 최적화: 비동기 작업을 기다리는 동안 스레드를 차단하지 않는다.대신 콜스택 상태를 저장하고 스레드를 다른 작업에 활용할 수 있다.

그래서 핵심은?

메모리사용: 코루틴은 전통적인 스레드보다 훨씬 적은 메모리를 사용한다.코루틴이 실행 상태를 필요에 따라 저장하고 복원하기 때문이다
비동기 처리: 코루틴은 비동기 처리에 최적화되어 있다.중단과 재개가 가능하므로, I/O 작업과 같은 블로킹 작업에 스레드를 낭비하지 않는다.
효율적인 자원 관리: 코루틴은 자원을 보다 효율적으로 관리할 수 있다.하나의 스레드에서 여러 코루틴을 실행할 수 있으며 이는 컨텍스트 스위칭 비용을 줄여준다.

기타

코루틴이 중단될 때, 현재의 실행상태는 컨티뉴에이션 객체에 저장되는데 컨티뉴에이션은 힙 메모리에 저장되며, 재개될 때 이 객체를 통해 실행 상태가 복원된다. 이는 코루틴이 실제 물리적인 스택 메모리를 연속적으로
사용하지 않음을 의미한다.
코루틴은 실행 중일 때 물리적인 스택을 사용하고, 중단과 재개를 수행할 때는 컨티뉴에이션(즉, 힙 메모리)을 사용한다
왜 가상의 스택 이라는 용어를..?

전통적인 스택과의 차별화: 일반적인 스레드는 물리적 스택 메모리를 연속적으로 사용하지만, 코루틴은 중단과 재개가 가능하며 이 과정에서 실행 상태는 힙 메모리에 위치하는 컨티뉴에이션 객체에 저장.이러한 차이점을
강조하기 위헤 가상의 라는 용어를 사용

---

# 6장 - 코루틴 빌더

launch 빌더

launch 빌더는 새로운 코루틴을 시작하고, 결과를 반환하지 않습니다(Unit을 반환).
주로 병렬 작업을 수행할 때 사용하며, 작업이 완료될 때까지 기다리지 않습니다.
launch로 시작된 코루틴은 부모 코루틴의 생명주기에 연결되어 부모가 취소되면 자식도 취소됩니다.

runBlocking 빌더

runBlocking은 현재 스레드를 블록하고 코루틴이 완료될 때까지 기다립니다.
주로 테스트나 메인 함수에서 코루틴 코드를 실행하기 위해 사용됩니다.
runBlocking 내부에서는 다른 코루틴을 시작할 수 있으며, 내부 코루틴이 모두 완료될 때까지 기다립니다.

async 빌더

async 빌더는 코루틴을 시작하고 Deferred 타입의 결과를 반환합니다.
반환된 Deferred 객체를 통해 나중에 결과값을 받을 수 있으며, await 함수를 호출하여 결과값을 기다릴 수 있습니다.
주로 결과 값을 반환하는 병렬 작업에 사용됩니다.

coroutineScope

코루틴 스코프의 인스턴스를 생성하여 코루틴을 관리할 수 있습니다.
CoroutineScope를 사용하면 코루틴의 생명주기를 해당 스코프의 생명주기에 연결할 수 있습니다. 즉, 스코프가 취소되면 스코프 내의 모든 코루틴도 취소됩니다.
사용자가 직접 스코프를 관리하고 싶을 때 사용합니다.

GlobalScope
애플리케이션의 생명주기와 동일한 글로벌 스코프를 제공합니다.
GlobalScope로 시작된 코루틴은 애플리케이션 전체에서 실행되며, 별도로 취소하지 않는 이상 애플리케이션이 종료될 때까지 계속 실행됩니다.
메모리 누수의 위험이 있으므로, 주의해서 사용해야 합니다.

코루틴 스코프의 선택은 코루틴의 생명주기와 애플리케이션의 구조에 따라 달라집니다. 일반적으로 GlobalScope의 사용은 권장되지 않으며, 가능하면 CoroutineScope를 사용하여 명확한 생명주기 관리와 자원
정리를 수행하는 것이 좋습니다.

---

# 7장 - 코루틴 컨텍스트

코루틴 컨텍스트

코루틴의 동작과 관련된 여러 설정을 담고 있는 정보의 집합.
코루틴의 실행 스레드, 코루틴의 이름, 사용할 디스패처와 같은 정보를 포함할 수 있다.
코틀린에서는 코루틴컨텍스트 인터페이스를 통해 관리한다.

확장함수: 기존 클래스에 새로운 메서드를 추가할 수 있는 코틀린 기능
코루틴의 launch 함수는 CoroutineScope 인터페이스의 확장 함수로 정의되어 있습니다.

이는 CoroutineScope 인스턴스에 대해 launch 함수를 호출할 수 있다는 의미.

리시버: 확장 함수가 호출되는 대상 객체를 리시버 라고 한다.
this 참조: 확장함수 내부에서는 리시버 객체를 this 키워드를 사용하여 참조할 수 있다.
key를 통한 Element 식별

코루틴 컨텍스트 내의 각 Element 는 고유한 Key 를 가지고 있습니다. Key 는 CoroutineContext.Key 인터페이스를 상속받아 구현됩니다. Key 의 주된 역할은 타입-안전한 방식으로 컨텍스트
내의 원소를 식별하고 접근하는 것입니다.
타입-안전한 접근

key 를 통해 컨텍스트 내의 원소에 접근할 때, 타입 안정성이 보장됩니다.
즉 Key를 사용하여 컨텍스트에서 원소를 추축할 때, 해당 원소는 Key에 지정된 타입으로 변환됩니다.
이는 컴파일 타임에 타입 체크가 가능하게 하여, 런타임에 잘못된 타입으로 인한 오류를 방지합니다.

컨텍스트 더하기

+ 연산자로 합칠 수 있다.이 기능은 연산자 오버로딩을 통해 구현되어 있다.

컨텍스트 폴딩

컨텍스트의 모든 요소에 대해 순차적으로 연산을 적용하는 과정을 의미한다.
이는 컬렉션에서의 fold 연산과 유사한 개념입니다.
fold 메서드는 컨텍스트 내의 각 Element 에 대해 지정된 함수를 실행하며, 이 함수는 누적된 결과와 현재 Element 를 인자로 받아 새로운 누적 결과를 반환합니다.

코루틴 컨텍스트와 빌더

코루틴컨텍스트는 코루틴의 데이터를 저장하고 전달하는 방법입니다.부모-자식 관계의 영향 중 하나로 부모는 기본적으로 컨텍스트를 자식에게 전달합니다.자식은 부모로부터 컨텍스트를 상속받는다고 할 수 있습니다.모든 자식은
빌더의 인자에서 정의된 특정 컨텍스트를 가질 수 있습니다.인자로 전달된 컨텍스트는 부모로부터 상속받은 컨텍스트를 대체합니다.

코루틴 컨텍스트의 역할: 코루틴 컨텍스트는 코루틴의 동작 방식, 스케줄링, 생명주기 관리 등을 결정합니다. 각 코루틴은 자신만의 컨텍스트를 가지며, 이를 통해 자신의 동작 환경을 설정합니다.
부모-자식 관계: 코루틴은 부모-자식 관계를 형성할 수 있으며, 이 관계는 작업의 계층 구조와 생명주기 관리에 영향을 줍니다. 일반적으로, 부모 코루틴이 취소되면 자식 코루틴도 취소됩니다.
컨텍스트의 상속: 코루틴을 생성할 때, 부모 코루틴의 컨텍스트는 기본적으로 자식 코루틴에게 전달됩니다. 이는 자식 코루틴이 부모 코루ㅋ틴과 동일한 동작 환경(예: 동일한 Dispatcher, Job 등)에서 실행되게
하기 위함입니다.
컨텍스트의 재정의: 자식 코루틴은 생성 시 받은 컨텍스트를 기반으로 자신의 컨텍스트를 재정의할 수 있습니다. 즉, 코루틴 빌더(예: launch, async)에 전달된 컨텍스트 인자는 부모로부터 상속받은 컨텍스트를
대체하거나 수정합니다. 이를 통해 자식 코루틴은 부모와 다른 설정(예: 다른 Dispatcher, 추가된 CoroutineName 등)을 가질 수 있습니다.

---

# 8장 - 잡과 자식 코루틴 기다리기

자식은 부모로부터 컨텍스트를 상속받습니다.
부모는 모든 자식이 작업을 마칠 때까지 기다립니다.
부모 코투린이 취소되면 자식 코루틴도 취소됩니다.
자식 코루틴에서 에러가 발생하면, 부모 코루틴 또한 에러로 소멸합니다.
Job 이란?

시작된 코루틴에 대한 핸들로 사용된다.
launch 코루틴 빌더는 Job 객체를 반환하고, 이 객체를 사용하여 코루틴이 완료될 때까지 대기하거나 코루틴의 상태를 관리할 수 있다.

코루틴 빌더는 부모의 잡을 기초로 자신들의 잡을 생성한다.

모든 코루틴 빌더는 자신만의 잡을 생성합니다.
대부분의 코루틴 빌더는 잡을 반환하므로 어느 곳에서든 사용할 수 있습니다.
launch 의 명시적 반환 타입이 Job 이라는 사실을 통해 확인할 수 있습니다.
Job 은 코루틴이 상속하지 않는 유일한 코루틴 컨텍스트이며, 이는 코루틴에서 아주 중요한 법칙입니다.
부모 잡은 자식 잡 모두를 참조할 수 있으며, 자식 또한 부모를 참조할 수 있습니다.
잡을 참조할 수 있는 부모-자식 관계가 있기 때문에 코루틴 스코프 내에서 취소와 예외 처리 구현이 가능합니다.

자식들 기다리기

join 메서드를 사용합니다.
join 은 지정한 잡이 Completed 나 Cancelled 와 같은 마지막 상태에 도달할 때까지 기다리는 중단 함수 입니다.

잡 팩토리 함수

Job 은 Job() 팩토리 함수를 사용하면 코루틴 없이도 Job을 만들 수 없습니다.
팩토리 함수로 생성하는 잡은 어떤 코루틴과도 연관되지 않으며, 컨텍스트로 사용될 수 있다.
한개 이상의 자식 코루틴을 가진 부모 잡으로 사용할수도 있다.

```kotlin
@Test
fun `코루틴 딥다이브 94페이지`() {
    runBlocking { // 메인 코루틴 시작
        val job = Job() // 부모 Job 생성

        launch(job) {// 첫번째 코루틴 시작
            repeat(5) { num ->
                delay(200)
                println("Rep$num")
            }
        }

        launch { // 독립적인 두번째 코루틴 시작
            delay(500)
            println("second")
            job.complete() // 첫 번째 코루틴의 부모 Job 을 완료 상태로 변경
        }

        job.join() // 첫 번째 코루틴 작업 완료를 기다림

        launch(job) { // 세번 째 코루틴 시작(부모 Job을 상속받음)
            println("Will not be printed")
        }

        println("Done")
    }
}
```

---

# 9장 - 취소

코틀린 코루틴에서 아주 중요한 기능 중 하나는 바로 취소(cancellation) 이다.
기본적인 취소

Job 인터페이스는 취소하게 하는 cancel 메서드를 가지고 있습니다. cancel 메서드를 호출하면 다음과 같은 효과를 가져올 수 있다.

호출한 코루틴은 첫 번째 중단점에서 잡을 끝냅니다.
잡이 자식을 가지고 있다면, 그들 또한 취소됩니다.하지만 부모는 영향을 받지 않는다.
잡이 취소되면, 취소된 잡은 새로운 코루틴의 부모로 사용될 수 없다. 취소된 Job 은 Cancelling 상태가 되었다가 Cancelled 상태로 바뀝니다.

``` kotlin 
@Test
fun `98페이지`() {
runBlocking {
val job = launch {
repeat(1_000) { i ->
delay(200)
println("Printing $i")
}
}

        delay(1100)
        job.cancel()
        job.join()
        println("Cancelled successfully")
    }
}

// Printing 0
// Printing 1
// Printing 2
// Printing 3
// Printing 4
// Cancelled successfully
```

코루틴을 취소하기 위해서 사용되는 예외는 cancellationException 이어야 하기 때문에 인자로 사용되는 예외는 반드시 cancellationException 의 서브타입이어야 한다

코루틴은 내부적으로 cancellationException 을 취소 메커니즘으로 사용.
이 예외들은 모든 핸들러에게 무시되므로, 추가적인 디버그 정보의 소스로만 사용되어야 한다.
예외를 catch 블록에서 캐치할 수 있다.

CancellationException 은

Job.cancel 을 사용하여 취소되며, 코루틴은 종료되지만 부모 코루틴은 취소하지는 않는다.

job.cancel() 메서드를 호출하면 코루틴은 CancellationException 을 받습니다.
해당 예외는 코루틴이 취소되었음을 나타내고, 코루틴은 다음 일시 중단 지점에서 멈추게 된다.

에러 처리와 차이점

CancellationException의 경우 코루틴의 정상적인 종료 부분으로 초리된다. 코루틴은 이 예외를 에러로 취급하지 않고, 코루틴의 실행을 멈춘다.

위 의 내용을 바탕으로 서브타입을 인자로 사용되는 예외는 CancellationException 의 서브타입이어야 한다.
cancel 이 호출된 뒤 다음 작업을 진행하기 전에 취소 과정이 완료되는 걸 기다리기 위해 join 을 사용하는 것이 일반적이다.

join 을 호출하지 않으면 레이스 컨디션 상태가 될 수 있다.

cancel 과 join 을 함께 호출할 수 있는 간단한 방법으로는 cancelAndJoin 이라는 확장 함수를 제공한다.

장 함수를 제공한다.

취소는 어떻게 작동하는가?

잡이 취소되면 Cancelling 상태로 바뀝니다.
상태가 바뀐 뒤 첫 번째 중단점에서 CancellationException 예외를 던집니다.

예외는 try-catch 구문을 사용하여 잡을 수도 있지만 다시 던지는 것이 좋습니다.

CancellationException 을 다시 던지면 코루틴이 취소된 것을 시스템이 알아차리고, 다른 코루틴들도 이를 인지할 수 있다.
CancellationException 은 올바르게 코루틴이 제대로 끝났다라는 신호이다. 다시 던진다면 코루틴이 문제 없이 종료되었다라는 것을 확실히 할 수 있다.
CancellationException 을 다시 던짐으로써 finally 블록이나 코루틴의 일시 중단 함수들은 여전히 실행될 수 있다.이를 통해 리소스를 적절히 해제할 수 있다.

취소된 코루틴이 단지 멈추는 것이 아니라 내부적으로 예외를 사용해 취소되는 걸 명심해야 한다.

취소 중 코루틴을 한 번 더 호출하기

코루틴이 실제로 종료되기 전에
CancellationException 을 잡고 좀더 많은 연산을 수행할 수 있다.
withContext 내부에서는 취소될 수 없는 Job인 NonCancellable 객체를 사용합니다. 따라서 블록 내부에서 잡은 액티브 상태를 유지하며, 중단 함수를 원하는 만큼 호출할 수 있다.
간단히 말해서 코루틴이 취소되더라도 필요한 정리 작업을 수행하려면 withContext(NonCancellable) 을 사용하여 취소되지 않는 특정 영역을 만들고, 그안에서 필요한 작업을 수행하면 된다.

invokeOnCompletion

자원을 해제하는 데 자주 사용되는 또 다른 방법은 Job 의 invokeOnCompletion 메서드를 호출하는 것이다.
invokeOnCompletion 메서드는 잡이 Completed 나 Cancelled 같은 마지막 상태에 도달했을 때 호출될 핸들러를 지정하는 역할을 한다.

중단될 수 없는 걸 중단하기

취소는 중단점에서 일어나기 때문에 중단점이 없으면 취소를 할 수 없습니다.
Thread.sleep() 은 안좋다

스레드를 블로킹한다.
취소가 불가능하다
응답성이 저하된다.

yield()

yield() 를 호출하면 현재 코루틴은 일시중지되며 이는 코루틴이 더 이상 실행 중이지 않음을 의미한다.
이는 스레드가 블록되는 것과는 다르다 코루틴은 일시 중지 상태가 되지만 실행 중이던 스레드는 다른 작업을 계속 수행할 수 있다.
현재 코루틴이 작업을 잠시 중단하고, 스케줄러에게 제어를 넘깁니다.스케줄러는 이후에 다른 코루틴에게 실행 기회를 제공할 수 있다.

중단 가능하지 않으면서 CPU 집약적이거나 시간 집약적인 연산들이 중단 함수에 있다면, 각 연사들 사이에 yield 를 사용하는 것이 좋다

yield() 함수를 사용하는 주된 이유는 애플리케이션의 응답성과 자원의 공정한 분배를 향상시키기 위해서이다.
응답성 향상

멀티태스킹 환경에서 한 태스크가 CPU 를 장시간 독점하면, 다른 태스크들은 실행될 기회를 잃게되고, 이는 전체 시스템의 반응 시간을 늘릴 수 있다.
yeild() 를 사용하면, CPU 집약적 작업을 수행하는 코루틴이 잠시 멈추고 다른 코루틴이 실행될 수 있는 기회를 준다. 이는 코루틴이나 태스크 간에 자원을 공유할 때 전체적인 응답성을 향상시킬 수 있다.

자원의 공정한 분배

여러 코루틴이 동시에 실행되는 환경에서, 모든 코루틴이 CPU 시간을 공정하게 받지 못하면, 일부 코루틴이 지나치게 오래 기다려야할 수 있다.

작업의 미세 조정

yield() 는 코드 내에서 코루틴의 실행을 조정할 수 있는 수단을 제공한다 예를 들어 대규모 데이터를 처리하는 작업에서 각 단계마다 yield() 를 호출하면 다른 코루틴도 중간중간 실행될 기회를 가질 수 있다.
이런 방식으로 yield() 를 사용하면 한 코루틴이 시스템의 모든 리소스를 독점하는 것을 방지하고, 작업을 좀 더 세밀하게 조정할 수 있어 전체적인 시스템의 효율성과 안정성을 높일 수 있다.

ensureActive

yield 와 비슷하지만 둘은 매우 다르다
함수는 현재 코루틴의 상태가 여전히 활성화되어 있는지 검사합니다. 만약 코루틴이 이미 취소되었다면, ensureActive()는 CancellationException을 던집니다.
사용 사례:장시간 실행되는 작업에서 정기적으로 코루틴이 취소되었는지 확인하고 싶을 때 사용합니다. 이를 통해 불필요한 작업을 중단하고, 코루틴의 자원을 빠르게 해제할 수 있습니다.

yield vs ensureActive

실행 양보 vs 상태 검사: yield는 현재 코루틴이 실행을 양보하는 데 중점을 둡니다. 반면, ensureActive는 코루틴의 상태를 검사하고, 코루틴이 취소되었는지 확인하는 데 사용됩니다.
사용 시점:yield는 다른 코루틴에게 실행을 공정하게 양보하고자 할 때 주로 사용되며, ensureActive는 코루틴이 장시간 작업을 수행하는 동안 여전히 활성 상태인지 확인하고자 할 때 사용됩니다.

suspendCancellableCoroutine

코루틴에서 취소 가능한 비동기 작업을 수행할 때 사용함
코틀린 코루틴 라이브러리 일부로, 기존의 콜백 기반 API 나 다른 비동기 작업을 코루틴과 호환되게 래핑하는데 유용하다.
suspendCancellableCoroutine 은 코루틴을 일시 중단하고, 외부의 비동기 작업이 완료될 때까지 기다린다. 비동기 작업이 완료되면 결과를 반환하거나 예외를 던질 수 있다.
취소가능: 취소를 지원한다. 취소되면 suspendCancellableCoroutine 블록내에서 등록한 취소 핸들러가 호출된다.

---
