#6장 - 클래스 설계

- item36: 상속보다는 컴포지션을 사용하라.
  - 컴포지션은 더 안전하고, 유연하고 명시적이다.
    - (컴포지션이란? 다른객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 메서드를 호출하는 기법이다)
  - 상속을 사용할때?
    - 명확한 is-a 관계일때
    - 슈퍼클래스를 상속받은 모든 서브클래스는 슈퍼클래스로도 동작할 수 있어야한다.
      - 슈퍼클래스의 단위테스트는 서브클래스로도 통과할 수 있어야 한다는 의미(LSP)
  - 오버라이딩 제한
    - 어떤 이유로 상속은 허용하지만, 메서드는 오버라이드하지 못하게 만들고 싶은 경우에는 open 키워드를 사용하자
    - 서브클래스에서 오버라이드할 수 있는 메서드를 제한하고 싶으면 final 키워드를 사용하자.
  - 컴포지션은 다른 클래스의 내부 구현에 의존하지 않기 때문에 더 안전합니다.
  - 컴포지션은 여러 클래스를 대상으로 할 수 있기 때문에 더 유연합니다.
  - 컴포지션은 this 리시버를 사용할 수 없기 때문에 리시버를 명시적으로 활용해야 해야 더 명시적입니다.
---

- item37: 데이터 집합 표현에 data 한정자를 사용하라.
  - 데이터를 표현할때는 data 클래스를 이용하는게 좋다.
  - data 한정자를 붙이면, 몇 가지 함수들이 자동으로 생성된다.
    - toString
    - equals 와 hashCode
    - copy (얕은 복사)
    - componentN(component1, component2 등)

---
- item38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라.
  - 메서드가 하나만 있는 인터페이스(SAM: Single-Abstract Method)
  - 코틀린이 아닌 다른 언어에서 사용할 클래스를 설계할 때에는 SAM 을 사용하자.

---
- item39: 태그 클래스보다는 클래스 계층을 사용하라.
  - 상수 '모드'를 태그(tag)라고 부르며, 태그를 호함한 클래스를 태그 클래스(tagged class) 라고 부른다.
  - sealed class 로 변경하자.
  - sealed class 장점
    - 외부 파일에서 서브클래스를 만드는 행위 자체를 모두 제한
    - 외부에서 추가적인 서브클래스를 만들 수 없으므로, 타입이 추가되지 않을 거라는게 보장이라 when()절에서 else 브랜치를 만들 필요가 없습니다

---

  

