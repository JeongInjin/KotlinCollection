#6장 - 클래스 설계

- item36: 상속보다는 컴포지션을 사용하라.
  - 컴포지션은 더 안전하고, 유연하고 명시적이다.
    - (컴포지션이란? 다른객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 메서드를 호출하는 기법이다)
  - 상속을 사용할때?
    - 명확한 is-a 관계일때
    - 슈퍼클래스를 상속받은 모든 서브클래스는 슈퍼클래스로도 동작할 수 있어야한다.
      - 슈퍼클래스의 단위테스트는 서브클래스로도 통과할 수 있어야 한다는 의미(LSP)
  - 오버라이딩 제한
    - 어떤 이유로 상속은 허용하지만, 메서드는 오버라이드하지 못하게 만들고 싶은 경우에는 open 키워드를 사용하자
    - 서브클래스에서 오버라이드할 수 있는 메서드를 제한하고 싶으면 final 키워드를 사용하자.
  - 컴포지션은 다른 클래스의 내부 구현에 의존하지 않기 때문에 더 안전합니다.
  - 컴포지션은 여러 클래스를 대상으로 할 수 있기 때문에 더 유연합니다.
  - 컴포지션은 this 리시버를 사용할 수 없기 때문에 리시버를 명시적으로 활용해야 해야 더 명시적입니다.
---

- item37: 데이터 집합 표현에 data 한정자를 사용하라.
  - 데이터를 표현할때는 data 클래스를 이용하는게 좋다.
  - data 한정자를 붙이면, 몇 가지 함수들이 자동으로 생성된다.
    - toString
    - equals 와 hashCode
    - copy (얕은 복사)
    - componentN(component1, component2 등)

---
- item38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라.
  - 메서드가 하나만 있는 인터페이스(SAM: Single-Abstract Method)
  - 코틀린이 아닌 다른 언어에서 사용할 클래스를 설계할 때에는 SAM 을 사용하자.

---
- item39: 태그 클래스보다는 클래스 계층을 사용하라.
  - 상수 '모드'를 태그(tag)라고 부르며, 태그를 호함한 클래스를 태그 클래스(tagged class) 라고 부른다.
  - sealed class 로 변경하자.
  - sealed class 장점
    - 외부 파일에서 서브클래스를 만드는 행위 자체를 모두 제한
    - 외부에서 추가적인 서브클래스를 만들 수 없으므로, 타입이 추가되지 않을 거라는게 보장이라 when()절에서 else 브랜치를 만들 필요가 없습니다

---
- item40: equals 의 규약을 지켜라.
  - data class 의 == 는 equals 로 자동으로 동등성 비교로 동작한다.
  - URL 과 관련된 equals 문제처럼 다른상태에 의존하여 동작이 일관되지 않게 설계하지말자.

---
- item41: hashCode 의 규악을 지켜라.
  - equals 를 따로 정의했다면 hashCode 도 함께 정의해 줘야한다.

---
- item42: compareTo 의 규약을 지켜라.
  - compareTo 메서드는 Any 클래스에 있는 메서드가 아니다.
  - 여러 프로퍼티를 기반으로 정렬해야 한다면
    - sortedWith
  - 두 값을 단순하게 비교하기만 한다면
    - compareValues
  - 더 많은 값을 비교하거나, 선택기(selector)를 활용해서 비교하고 싶다면
    - compareValuesBy

---
- item43: API 의 필수적이지 않은 부분을 확장 함수로 추출하라.
  - 클래스의 메서드를 정의할 때는 메서드를 멤버로 정의할 것인지 아니면 확장 함수로 정의할 것인지 결정해야 한다.
  - 확장은 따로 가져와서 사용해야한다.
    - 일반적으로 확장은 다른 패키지에 위치합니다.
    - 임포트해서 사용한다는 특징 덕분에 같은 타입에 같은 이름으로 여러개 만들 수 있다.
    - 확장은 가상이 아니다.
      - 파생 클래스에서 오버라이드할 수 없다
    - 클래스 레퍼런스에서 멤버로 표시되지않는다.
      - 어노테이션 프로세서가 따로 처리하지 않는다.
    - 어노테이션 프로세서
      - 
      - Java 5 에서 처음 등장했다(Java 6 부터 활성화)
      - 컴파일 단계에서 추가 소스 파일을 생성하는 편리한 기술
      - 소스파일, 메타 데이터, 문서, 리소스 등을 생성한다.
      - "일반적으로 어노테이션에 대한 코드베이스를 검사, 수정 또는 생성하는데 사용된다."
      - 어노테이션 프로세싱은 컴파일 시간에 어노테이션들을 스캐닝하고 프로세싱하는 javac 에 속한 빌드툴

---
- item44: 멤버 확장 함수의 사용을 피하라.
```kotlin
//확장 함수는 컴파일 시 단순한 일반 함수로 컴파일 된다.
//단순히 변환되는 것이므로 확장 함수를 아래와 같이 클래스 멤버로 정의할 수도 있고, 인터페이스 내부에 정의할 수도 있다.
//DSL 을 만들때를 제외하면 이를 사용하지 말자.
interface PhoneBook {
    fun String.isPhoneNumber(): Boolean
}

class Fizz: PhoneBook {
    override fun String.isPhoneNumber(): Boolean {
        return length == 7 && all { it.isDigit() }
    }
}
```
- 아래와 같은 이유로 확장함수를 클래스 멤버로 정의하지 않는게 좋다.
  - 가시성을 제한하지 못한다.
  - 레퍼런스를 지원하지 않는다 ::
  - 경험이 적은 개발자가 보면 직관적이지 않는다.

---
  

