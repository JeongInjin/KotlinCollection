#1장 - 안정성

- item1: 가변성을 제한하라.
  - var 보단 val 을 사용하자.
  - immutable 프로퍼티를 사용하자.
  - 컬렌션을 다운캐스팅 하지말자
  - 변경이 필요하 대상을 만들어야 한다면, immutable 데이터 클래스로 만들고 copy 를 활용하자.

- item2: 변수의 스코프를 최소화하라.
  - 변수의 스코르는 좁게 만들어서 활용하자.
  - 람다에서 변수를 캡처 한다는것을 기억하자.

- item3: 최대한 플랫폼 타입을 사용하지 말라.
  - 다른 프로그래밍 언어에서 와서 nullable 여부를 알 수 없는 타입을 **"플랫폼 타입"** 이라 부른다.
  - 이는 위험한 잠재적 코드이니..NPE..
  - 이런 코드가 있다면, 빠른 제거 또는 자바 생성자, 메서드, ㅍ필드에 nullable 여부를 지정하는 어노테이션을 활용하는 것도 좋다

- item4: 추론(inferred)*인퍼드 타입으로 리턴하지 말라.
  - 타입 추론은 코틀린의 특징 중 하나이다.
  - 할당 때 inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설정된다.
    - 슈펴클래스 또는 인터페이스로는 설정되지 않는다.
  - 결론: 타입을 확실하게 지정해야 하는 경우에는 명시적으로 타입을 지정해야 한다.
  - 지정한 타입은 특별한 이유와 확실한 확인 없이는 제거하면 안된다.
  - 주의: inferred 타입은 프로젝트가 진전될 때, 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수 있다.

- item5: 예외를 활용해 코드에 제한을 걸어라
  - 제한 키워드를 사용하여 이득을 얻을 수 있다.
  - 음..해당 아이템은 개인적으로는 require 또는..원래하던데로 Elvis 연산자를 사용해서 throw 할듯..
  - -> 하던대로 하면 됨.

- item6: 사용자 정의 오류보다는 표준 오류를 사용하라.
  - 가급적 표준 라이브러리 오류를 사용하자.

- item7: 결과 부족이 발생할 경우 null 과 Failure 를 사용하라.
  - 예측가능한 범위의 오류는 null 과 Failure 를 사용하고, 
  - 예측하기 어려운 예외적인 범위의 오류를 throw 해서 처리하자.

- item8: 적절하게 null 을 처리하라.
  - 처음 사용하기 전에 반드시 초기화가 하여 사용되어야 할경우 lateinit 키워드를 사용하고
  - JVM 에서 Unt ,Long, Double, Boolean 과 같은 기본 타입과 연결된 타입으로 프로퍼티를 초기화 해야할 경우에는 Delegates.notNull 을 사용하자.

-item9: use 를 사용하여 리소스를 닫아라.
  - 더 이상 필요하지 않을때, close 메서드를 사용해 명시적으로 닫아야 하는 리소스가 있다.
  - InputStream / OutputStream
  - java.sql.Connection
  - java.io.Reader
  - java.new.Socket / java.uti.Scanner
  - 등이 있는데, 이러한 리소스들은 AutoCloseable 을 상속받은 Closeable 인터페이스를 구현하고 있다.
  - 이러한 모든 리소스는 최종적으로 리소스에 대한 레퍼런스가 없어질 때, 가바지 컬렉터가 처리한다.
  - 하지만, 굉장히 느리며 그동안 리소스를 유지하는 비용이 많이 들어간다.
  - 기존구현은 try-finally 방식으로 많이 처리했지만, 
  - use 키워드를 사용하여 close 하자.
    - 파일을 처리할 때는 파일을 한 줄씩 읽어 들이는 useLines 를 사용하는 것이 좋다.
  
  - item10: 단위 테스트를 만들어라
    - 단위테스트를 만들어라.
